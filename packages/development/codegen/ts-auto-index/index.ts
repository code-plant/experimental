#!/usr/bin/env node

import { Args } from "@this-project/development-util-args";
import {
  existsSync,
  lstatSync,
  readdirSync,
  readFileSync,
  writeFileSync,
} from "node:fs";
import { join, resolve } from "node:path";

import {
  ClassDeclaration,
  createSourceFile,
  Declaration,
  EnumDeclaration,
  FunctionDeclaration,
  getCombinedModifierFlags,
  InterfaceDeclaration,
  isClassDeclaration,
  isEnumDeclaration,
  isExportDeclaration,
  isFunctionDeclaration,
  isIdentifier,
  isInterfaceDeclaration,
  isNamedExports,
  isTypeAliasDeclaration,
  isVariableStatement,
  ModifierFlags,
  ScriptTarget,
  SyntaxKind,
  TypeAliasDeclaration,
  VariableStatement,
} from "typescript";

/**
 * Recursively walks through directories, generating index.ts for each.
 * Subdirectories are processed first; then the current directory is processed.
 */
function generateIndexesRecursively(rootDir: string): void {
  // 1. Recurse into subdirectories first
  const entries = readdirSync(rootDir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const subDir = join(rootDir, entry.name);
      generateIndexesRecursively(subDir);
    }
  }

  // 2. Generate index.ts for the current directory afterward
  generateIndexForDirectory(rootDir);
}

/**
 * Generates an index.ts in `dir`, containing `export type {...}` for each top-level exported declaration.
 * Also handles subdirectory `index.ts` exports.
 */
function generateIndexForDirectory(dir: string): void {
  const entries = readdirSync(dir, { withFileTypes: true });

  const exportStmts: string[] = [];

  // For each .ts file (excluding .d.ts and index.ts), gather exported names
  const tsFiles = entries.filter(
    (e) =>
      e.isFile() &&
      e.name.endsWith(".ts") &&
      !e.name.endsWith(".d.ts") &&
      e.name !== "index.ts"
  );

  for (const file of tsFiles) {
    const filePath = join(dir, file.name);
    const exportedNames = getExportedIdentifiers(filePath);

    if (exportedNames.length > 0) {
      const baseName = file.name.replace(/\.ts$/, "");
      exportStmts.push(
        `export type { ${exportedNames.join(", ")} } from './${baseName}';`
      );
    }
  }

  // For each subdirectory that has an index.ts, gather exported identifiers
  const subDirs = entries.filter((e) => e.isDirectory());
  for (const subDir of subDirs) {
    const subIndexTs = join(dir, subDir.name, "index.ts");
    if (existsSync(subIndexTs)) {
      const exportedNames = getExportedIdentifiers(subIndexTs);
      if (exportedNames.length > 0) {
        exportStmts.push(
          `export type { ${exportedNames.join(", ")} } from './${subDir.name}';`
        );
      }
    }
  }

  // Write the index.ts if we have anything to export
  if (exportStmts.length > 0) {
    exportStmts.sort();
    const filePath = join(dir, "index.ts");
    writeFileSync(
      filePath,
      "// THIS FILE IS AUTOMATICALLY GENERATED BY ts-auto-index.\n" +
        exportStmts.join("\n") +
        "\n",
      "utf-8"
    );
    console.log(`Created/updated index.ts in: ${dir}`);
  }
}

/**
 * Parses the given .ts file and returns an array of named exports.
 * Generates names only, ignoring default exports or `export *`.
 * All found declarations (class, function, interface, etc.) are treated as type exports.
 */
function getExportedIdentifiers(filePath: string): string[] {
  const sourceText = readFileSync(filePath, "utf8");
  const sourceFile = createSourceFile(
    filePath,
    sourceText,
    ScriptTarget.ESNext,
    /* setParentNodes */ true
  );

  const exportedNames: string[] = [];

  sourceFile.forEachChild((node) => {
    // 1) Exported declarations with "export" keyword
    if (
      (isClassDeclaration(node) ||
        isFunctionDeclaration(node) ||
        isInterfaceDeclaration(node) ||
        isEnumDeclaration(node) ||
        isTypeAliasDeclaration(node)) &&
      hasExportKeyword(node)
    ) {
      // e.g. `export class Foo`, `export interface Bar`, `export function Baz`
      if (node.name) {
        exportedNames.push(node.name.text);
      }
    } else if (isVariableStatement(node) && hasExportKeyword(node)) {
      // e.g. `export const foo = ...`
      for (const decl of node.declarationList.declarations) {
        if (isIdentifier(decl.name)) {
          exportedNames.push(decl.name.text);
        }
      }
    }
    // 2) Re-export statements
    else if (isExportDeclaration(node)) {
      // e.g. `export { Foo, Bar as Baz } from './somewhere'`
      // or `export * from './somewhere'`
      // skip `export * from` because there's no named list
      if (node.exportClause && isNamedExports(node.exportClause)) {
        for (const spec of node.exportClause.elements) {
          // e.g. `export { Foo as Bar }`
          // `spec.name` is the local exported name (Bar)
          exportedNames.push(spec.name.text);
        }
      }
    }
    // 3) `export default` or `export = ...` => skip or handle differently
    // If needed, handle it here. For purely type re-exports, we typically skip default exports
  });

  return exportedNames;
}

/**
 * Helper to detect if a node has `export` in its modifiers.
 */
function hasExportKeyword(
  node:
    | ClassDeclaration
    | FunctionDeclaration
    | InterfaceDeclaration
    | EnumDeclaration
    | TypeAliasDeclaration
    | VariableStatement
): boolean {
  // If TS >= 5, you can use: `ts.getModifiers(node)?.some(...)`
  // For backwards compatibility, do:
  return (
    (!!node.modifiers?.some((m) => m.kind === SyntaxKind.ExportKeyword) ||
      getCombinedModifierFlags(node as Declaration) & ModifierFlags.Export) !==
    0
  );
}

/**
 * Main entry point for CLI usage: npx generate-index [targetDir?]
 */
function main() {
  const args = Args.instance
    .positional(Args.STRING)
    .boolean("types-only", "t")
    .parse(process.argv.slice(2));
  if (args.type === "error") {
    throw new Error(args.reason);
  } else if (args.type === "version") {
    console.log("Version 0.1.0");
    process.exit(0);
  } else if (args.type === "help") {
    console.log(`Usage: node ${process.argv[1]} [...options] targetDir
Options:
  -t --types-only: export types only
`);
    process.exit(0);
  }
  const [targetDir] = args.positional;
  if (!args.keywords["types-only"]) {
    throw new Error("Currently, --types-only must be specified.");
  }

  const fullPath = resolve(targetDir);

  if (!existsSync(fullPath) || !lstatSync(fullPath).isDirectory()) {
    console.error(`Invalid directory: ${fullPath}`);
    process.exit(1);
  }

  generateIndexesRecursively(fullPath);
  console.log(`Done generating index.ts files under: ${fullPath}`);
}

main();
