#!/usr/bin/env node

import { Args } from "@this-project/development-util-args";
import {
  existsSync,
  lstatSync,
  readdirSync,
  readFileSync,
  writeFileSync,
} from "node:fs";
import { join, resolve } from "node:path";

import {
  createSourceFile,
  isClassDeclaration,
  isEnumDeclaration,
  isFunctionDeclaration,
  isIdentifier,
  isInterfaceDeclaration,
  isTypeAliasDeclaration,
  isVariableStatement,
  ScriptTarget,
  SyntaxKind,
} from "typescript";

/**
 * Recursively walks through directories, generating index.ts for each.
 * Subdirectories are processed first; then the current directory is processed.
 */
function generateIndexesRecursively(rootDir: string): void {
  // 1. Recurse into subdirectories first
  const entries = readdirSync(rootDir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const subDir = join(rootDir, entry.name);
      generateIndexesRecursively(subDir);
    }
  }

  // 2. Generate index.ts for the current directory afterward
  generateIndexForDirectory(rootDir);
}

/**
 * Generates an index.ts in `dir`, containing `export type {...}` for each top-level exported declaration.
 * Also handles subdirectory `index.ts` exports.
 */
function generateIndexForDirectory(dir: string): void {
  const entries = readdirSync(dir, { withFileTypes: true });

  const exportStmts: string[] = [];

  // For each .ts file (excluding .d.ts and index.ts), gather exported names
  const tsFiles = entries.filter(
    (e) =>
      e.isFile() &&
      e.name.endsWith(".ts") &&
      !e.name.endsWith(".d.ts") &&
      e.name !== "index.ts"
  );

  for (const file of tsFiles) {
    const filePath = join(dir, file.name);
    const exportedNames = getExportedIdentifiers(filePath);

    if (exportedNames.length > 0) {
      const baseName = file.name.replace(/\.ts$/, "");
      exportStmts.push(
        `export type { ${exportedNames.join(", ")} } from './${baseName}';`
      );
    }
  }

  // For each subdirectory that has an index.ts, gather exported identifiers
  const subDirs = entries.filter((e) => e.isDirectory());
  for (const subDir of subDirs) {
    const subIndexTs = join(dir, subDir.name, "index.ts");
    if (existsSync(subIndexTs)) {
      const exportedNames = getExportedIdentifiers(subIndexTs);
      if (exportedNames.length > 0) {
        exportStmts.push(
          `export type { ${exportedNames.join(", ")} } from './${subDir.name}';`
        );
      }
    }
  }

  // Write the index.ts if we have anything to export
  if (exportStmts.length > 0) {
    exportStmts.sort();
    const filePath = join(dir, "index.ts");
    writeFileSync(
      filePath,
      "// THIS FILE IS AUTOMATICALLY GENERATED BY ts-auto-index.\n" +
        exportStmts.join("\n") +
        "\n",
      "utf-8"
    );
    console.log(`Created/updated index.ts in: ${dir}`);
  }
}

/**
 * Parses a .ts file with the TypeScript Compiler API and returns an array of top-level exported identifiers.
 */
function getExportedIdentifiers(filePath: string): string[] {
  const sourceText = readFileSync(filePath, "utf8");
  const sourceFile = createSourceFile(
    filePath,
    sourceText,
    ScriptTarget.ESNext,
    true
  );

  const exportedNames: string[] = [];
  sourceFile.forEachChild((node) => {
    if (
      "modifiers" in node &&
      Array.isArray(node.modifiers) &&
      node.modifiers.some((m) => m.kind === SyntaxKind.ExportKeyword)
    ) {
      // e.g. export class Foo, export interface Bar, export function Baz, export type Qux, etc.
      if (
        isClassDeclaration(node) ||
        isInterfaceDeclaration(node) ||
        isEnumDeclaration(node) ||
        isFunctionDeclaration(node) ||
        isTypeAliasDeclaration(node)
      ) {
        if (node.name) {
          exportedNames.push(node.name.escapedText.toString());
        }
      } else if (isVariableStatement(node)) {
        // export const Foo = ...
        for (const decl of node.declarationList.declarations) {
          if (isIdentifier(decl.name)) {
            exportedNames.push(decl.name.escapedText.toString());
          }
        }
      }
    }
  });

  return exportedNames;
}

/**
 * Main entry point for CLI usage: npx generate-index [targetDir?]
 */
function main() {
  const args = Args.instance
    .positional(Args.STRING)
    .boolean("types-only", "t")
    .parse(process.argv.slice(2));
  if (args.type === "error") {
    throw new Error(args.reason);
  } else if (args.type === "version") {
    console.log("Version 0.1.0");
    process.exit(0);
  } else if (args.type === "help") {
    console.log(`Usage: node ${process.argv[1]} [...options] targetDir
Options:
  -t --types-only: export types only
`);
    process.exit(0);
  }
  const [targetDir] = args.positional;
  if (!args.keywords["types-only"]) {
    throw new Error("Currently, --types-only must be specified.");
  }

  const fullPath = resolve(targetDir);

  if (!existsSync(fullPath) || !lstatSync(fullPath).isDirectory()) {
    console.error(`Invalid directory: ${fullPath}`);
    process.exit(1);
  }

  generateIndexesRecursively(fullPath);
  console.log(`Done generating index.ts files under: ${fullPath}`);
}

main();
